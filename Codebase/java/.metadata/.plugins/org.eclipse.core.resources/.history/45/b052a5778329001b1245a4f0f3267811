package Assignment3;

import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.Random;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Utility 
{
	private static BigInteger zero = new BigInteger("0");
	private static BigInteger one = new BigInteger("1");
	private static BigInteger two = new BigInteger("2");
	private final static String IPAD = "0x5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c";
	private final static String OPAD = "0x36363636363636363636363636363636363636363636363636363636363636";

	
	public static BigInteger RSA(BigInteger phi, BigInteger rsaPublicKey)
	{
		BigInteger rsaKey = GCD(rsaPublicKey, phi);
		
		return rsaKey;
	}
	
	/*/ Extended Euclidean Algorithm
	public static BigInteger EEA(BigInteger a, BigInteger b) 
	{
		BigInteger[] values = GCD(a, b);
		return values[2];
	}*/

	// Return array for steps of the EEA
	public static BigInteger GCD(BigInteger p, BigInteger q) 
	{
		BigInteger gcd = new BigInteger("1");
		
        for(BigInteger i = BigInteger.ONE; ((i.compareTo(p) < 1) && (i.compareTo(q) < 1)); i.add(BigInteger.ONE))
        {
            if(p.mod(i).compareTo(BigInteger.ZERO) == 0 && q.mod(i).compareTo(BigInteger.ZERO) == 0)
                gcd = i;
        }
        
        return gcd;
	}
	
	/*/ Return array for steps of the EEA
	public static BigInteger[] GCD(BigInteger p, BigInteger q) 
	{
		if (q.equals(BigInteger.ZERO))
			return new BigInteger[] { p, BigInteger.ONE, BigInteger.ZERO };

		BigInteger[] values = GCD(q, p.mod(q));
		BigInteger modResult = values[0];
		BigInteger primeExponent = values[2];

		// getting the publicKeyExponent is the goal of the Extended Euclidean Algorithm
		// publicKeyExponent = previous publicKeyExponent - (prime totient / public key)
		// * primeExponent
		BigInteger publicKeyExponent = values[1].subtract((p.divide(q)).multiply(values[2]));

		return new BigInteger[] { modResult, primeExponent, publicKeyExponent };
	}*/

	public static BigInteger FastExponentation(BigInteger base, BigInteger exponent, BigInteger modulus) 
	{
		// given x^y, where y = 1.
		if (modulus.equals(one))
			return base;

		BigInteger result = BigInteger.ONE;

		while (exponent.compareTo(zero) == 1) {
			int r = 3;
			if (exponent.testBit(1))
				result = result.multiply(base).mod(modulus);
			exponent = exponent.shiftRight(2);
			base = base.multiply(base).mod(modulus);
		}

		return result;
	}

	public static String GetSha256(String value) 
	{
		try 
		{
			MessageDigest message = MessageDigest.getInstance("SHA-256");
			message.update(value.getBytes());
			return BytesToHex(message.digest());
		} 
		catch (Exception ex) 
		{
			throw new RuntimeException(ex);
		}
	}

	
	private static String BytesToHex(byte[] byteString) 
	{
		StringBuffer result = new StringBuffer();
		for (byte b : byteString)
			result.append(Integer.toString((b & 0xff) + 0x100, 16).substring(1));
		
		return result.toString();
	}

	public static BigInteger Pow(BigInteger base, BigInteger exponent) 
	{
		BigInteger result = BigInteger.ONE;
		
		while (exponent.signum() > 0) 
		{
			if (exponent.testBit(0))
				result = result.multiply(base);
			base = base.multiply(base);
			exponent = exponent.shiftRight(1);
		}
		
		return result;
	}

	// Generate a random 1024-bit probable prime number
	public static BigInteger GeneratePrime(int bitSize) 
	{
		boolean primeFound = false;

		BigInteger primeCandidate = new BigInteger(1024, new Random());

		do 
		{
			primeCandidate = new BigInteger(1024, new Random());
			if (primeCandidate.isProbablePrime(12)) 
			{
				primeFound = true;
			}
		} 
		while (!primeFound);

		return primeCandidate;
	}

	// Cipher block chaining for encrypting plaintext.
	public static String CBCEncryption(String message, String privateKey, String iv) throws Exception
	{
		String[] messageSubstrings = new String[4];
		
		for (int i = 0; i < 4; i++)
		{
			messageSubstrings[i] = message.substring(i * 32, (i+1)*32);
		}
		
		String cipher = iv;
		String cipherData = "";
		byte[] privateBytes = HexToByteArray(privateKey);
		
		for (int i = 0; i < 4; i++) 
		{
			byte[] cipherBytes = HexToByteArray(messageSubstrings[i]);
					
			Cipher encryption = Cipher.getInstance("AES/CBC/NOPADDING");
			byte[] ivBytes = HexToByteArray(cipher);
			
			SecretKey aesKey = new SecretKeySpec(privateBytes, "AES");
			
			encryption.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(ivBytes));
			
	        byte[] cipherText = encryption.update(cipherBytes);
	      
	        cipher = bytesToHex(cipherText);
	        cipherData += cipher;
		}

		return cipherData;
	}

	// Cipher block chaining for decrypting plaintext.
	public static String CBCDecryption(String message, String privateKey, String iv) throws Exception 
	{
		String[] messageSubstrings = new String[4];
		
		for (int i = 0; i < 4; i++)
		{
			messageSubstrings[i] = message.substring(i * 32, (i+1)*32);
		}
		
		String decipher = iv;
		String deciphered = "";
		byte[] privateBytes = HexToByteArray(privateKey);
		
		for (int i = 0; i < 4; i++) 
		{	
			if (i > 0)
			{
				decipher = messageSubstrings[i - 1];
			}
			byte[] ivBytes = Utility.HexToByteArray(decipher);
			byte[] decipherBytes = HexToByteArray(messageSubstrings[i]);
			Cipher decryption = Cipher.getInstance("AES/CBC/NOPADDING");
			
			SecretKey aesKey = new SecretKeySpec(privateBytes, "AES");
			
			decryption.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(ivBytes));
			
	        byte[] decipherText = decryption.update(decipherBytes);
	        deciphered += new String(decipherText, StandardCharsets.UTF_8);
		}
		
		return deciphered;
	}

	// Hashed Message Authentication Code for user integrity
	public static String HMAC(String encryptedKey, String message) 
	{
		char charArray[] = new char[encryptedKey.length()];

		return GetSha256(XOR(encryptedKey, OPAD) + GetSha256(XOR(encryptedKey, IPAD) + message));
	}

	// Perform an XOR operation on 2 strings.
	public static String XOR(String x, String y) 
	{
		String result = "";

		for (int i = 0; i < x.length(); i++) 
		{
			result += toHex(fromHex(x.charAt(i)) ^ fromHex(y.charAt(i)));
		}

		return result;
	}

	// Convert a regular string to hexadecimal.
	public static String StringToHex(String input) 
	{
		return String.format("%040x", new BigInteger(1, input.getBytes()));
	}
	
	public static String bytesToHex(byte[] bytes) 
	{
		char[] hexArray = "0123456789abcdef".toCharArray();
	    char[] hexChars = new char[bytes.length * 2];
	    
	    for (int j = 0; j < bytes.length; j++) 
	    {
	        int v = bytes[j] & 0xFF;
	        hexChars[j * 2] = hexArray[v >>> 4];
	        hexChars[j * 2 + 1] = hexArray[v & 0x0F];
	    }
	    
	    return new String(hexChars);
	}
	
	/* s must be an even-length string. */
	public static byte[] HexToByteArray(String s) {
	    int len = s.length();
	    byte[] data = new byte[len / 2];
	    for (int i = 0; i < len; i += 2) {
	        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
	                             + Character.digit(s.charAt(i+1), 16));
	    }
	    return data;
	}

	// Generate a 16-byte initialisation vector.
	public static String GenerateIV() 
	{
		String hexIV = "";
		Random rd = new Random();
		for (int i = 0; i < 4; i++) 
		{
			hexIV += Integer.toHexString(rd.nextInt());
		}

		return hexIV;
	}
	
	private static int fromHex(char c) {
	    if (c >= '0' && c <= '9') {
	        return c - '0';
	    }
	    if (c >= 'a' && c <= 'f') {
	        return c - 'a' + 10;
	    }
	    throw new IllegalArgumentException();
	}

	private static char toHex(int nybble) {
	    if (nybble < 0 || nybble > 15) {
	        throw new IllegalArgumentException();
	    }
	    return "0123456789abcdef".charAt(nybble);
	}
}
