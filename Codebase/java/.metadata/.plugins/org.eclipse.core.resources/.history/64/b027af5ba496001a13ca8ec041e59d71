/**
 * Defines the LinkedList class, a circular doubly-linked list of
 * PlanarShapes.
 *
 * Author: Sam Dolbel
 * Date created: 19/3/2020
 * Date modified: 23/3/2020
 */

import java.util.Iterator;

public class LinkedList<E> implements Iterable<E>
{
	private Node sentinel;	// the first and last node in the list
	private Node current;	// the currently selected node in the list
	int count;	// the number of shapes in the list

	public LinkedList()
	{
		count = 0;
	}

	public int Count()	// get number of shapes
	{
		return count;
	}

	public Node GetCurrent()	// get currently selected node
	{
		return current;
	}

	public Node GetSentinel()	// get the sentinel node, the first node in the list
	{
		return sentinel;
	}

	public java.util.Iterator<E> iterator() 
	{
		return new LinkedIterator();
	}

	public void Prepend(Node _shape)	// add a node to the start of the list - this will be the new sentinel node
	{
		Append(_shape);
		sentinel = _shape;
	}

	public void Append(Node _shape)
	{
		Node shape = _shape;
		if (count == 0)	// if list is empty, add the shape
		{
			shape.SetNext(shape);	// if list count = 1, next and previous nodes to sentinel node are still the sentinel node
			shape.SetPrevious(shape);
			sentinel = shape;	// new node becomes sentinel node
		}
		else
		{
			shape.SetPrevious(sentinel.GetPrevious());	// previous node of new node is the old end of the list
			sentinel.GetPrevious().SetNext(shape);	// next node of the old end node is the new node
			sentinel.SetPrevious(shape);	// previous node of the sentinel node is the new node - making the new node the end node
			if (count == 1)
				sentinel.SetNext(shape);	// if list only contains 2 nodes, next node of the sentinel node is the new node

			shape.SetNext(sentinel);	// next node of the new node is the sentinel node
		}
		Reset();	// return current node to the start of the list
		count++;	// new shape added
	}

	public void Insert(Node _shape)
	{
		Node temp = current.GetPrevious();	// get a temporary reference to the node before the current node for convenience
		Node shape = _shape;
		shape.SetPrevious(temp); 	// previous node of the new node is the node that used to be previous to the current node
		current.SetPrevious(shape);	// previous node of the current node is the new node
		temp.SetNext(shape);	    // next node of the node formerly previous to the current node is the new node
		shape.SetNext(current);	    // next node of the new node is the current node
		count++;	// new shape added
 	}

	public void Next()	// make current node the next node in the list
	{
		current = current.GetNext();
	}

	public void Reset()	// return the current node to the beginning of the list
	{
		current = sentinel;
	}

	public Node Remove()	// remove the node from the front of the list
	{
		Reset();	// return current node to the start of the list
		Node removedShape = sentinel;
		if(sentinel.GetNext() != null) // check if sentinel node is the last node
		{
		    Next();	// move to the next node
			sentinel.GetPrevious().SetNext(current);	// next node of the last node becomes the second node in the list
			current.SetPrevious(sentinel.GetPrevious());	// previous node of the second node becomes the last node in the list
			sentinel = null;	// old sentinel is removed
			sentinel = current;	// second node becomes new sentinel
		}
		else	// list is now empty - remove all nodes
		{
		    sentinel = null;
		    current = null;
		}
		count--;	// shape deleted from list
		return removedShape;	// return the removed shape
	}
	
	public String ToString()
	{
		String listString = "";
		Iterator iterator = this.iterator();
		while (iterator.hasNext())
			listString += iterator.next().toString();
			
		return listString;
	}
  
	private class LinkedIterator implements Iterator<E>
	{
		private int currentIndex;
		
		public LinkedIterator()
		{
			currentIndex = 0;
		}
		
		public boolean hasNext() 
		{
			return currentIndex < count - 1;
		}

		public E next()
		{
			E obj = null;
			currentIndex++;
			return obj;
		}

		public void remove(int _index)
		{
	  
		}
	}
}
